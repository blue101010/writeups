# Challenge : Baby-RSA

Source : https://jsur.in/posts/2021-04-25-s4ctf-crypto-writeups 
Note :  A CTF from S4lab   Sharif University of Technology in 2021 (public research university in Tehran, Iran) ref https://ctftime.org/ctf/614/


A widely used crypto protocol, which may have been implemented weakly. What do you think?

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from Crypto.Util.number import *
from flag import flag

def create_tuple(nbit): # sorry for dirty code that is not performant!
	while True:
		p, q = [getPrime(nbit) for _ in range(2)]
		P = int(str(p) + str(q))
		Q = int(str(q) + str(p))
		if isPrime(P) and isPrime(Q):
			return P, Q

def encrypt(msg, pkey):
	return pow(bytes_to_long(msg), 31337, pkey)

nbit = 256
P, Q = create_tuple(nbit)
pkey = P * Q
enc = encrypt(flag.encode('utf-8'), pkey)

print('pkey =', pkey)
print('enc =', enc)
```


# Solution
A 1024 bit RSA modulus is generated by choosing two random 256 bit primes p and q, and constructing the 512 bit primes P = int(str(p) + str(q)) and Q = int(str(q) + str(p)) (such primes p and q seem to be quite rare; I wasn't able to get local values to test with before I solved the challenge).

We'll make the assumption that there are 77 digits in both p and q (this is the case in the challenge, but if it weren't, we could just try with different values around 77). Then

$$
P = 10^{77}p + q \\
Q = 10^{77}q + p
$$

â€‹
 
So the bivariate polynomial
$$
f(x, y) = N - (10^{77}x + y)(10^{77}y + x)
$$

has "small" roots, which can be easily found using Coppersmith's theorem. As usual, we use defund's implementation, but it seems to not work over ZZ that well, so we construct the polynomial ring over Zmod(N^2) (or some other big number such that N doesn't vanish).

Sage script:
```
from Crypto.Util.number import long_to_bytes
load('small_roots.sage')

N = 48564396752059338791464352725210493148212425902751190745668164451763507023284970474595680869078726765719920168392505794415687815488076204724659643390252172928332322944711949999326843460702414647825442748821062427474599006915155109396213406624079900714394311217571510958430682853948004734434233860146109894977
enc = 28767981118696173499362412795754123415661648348744243377735885542432968964926551295510845917978847771440173910696607195964650864733310997503291576565605508828208679238871651079005335403223194484223700571589836641593207297310906538525042640141507638449129445170765859354237239005410738965923592173867475751585

R.<x,y> = PolynomialRing(Zmod(N^2))
P = 10^77 * x + y
Q = 10^77 * y + x
f = N - P*Q
p, q = small_roots(f, (10^77, 10^77), m=3)[0]

P = int(str(p) + str(q))
Q = int(str(q) + str(p))
d = pow(31337, -1, (P-1)*(Q-1))
m = pow(enc, d, N)
print(long_to_bytes(m).decode())
```

```
Flag: S4CTF{Wh3n_mY_BrA1n_w45_UltR4_4CtIVe_ABOut_RSA!!!}
```


# Analysis

## The Challenge Solution's Assumption

The challenge solution assumes the size of `p` and `q` to be precisely 77 digits due to the way the primes `P` and `Q` are generated in the given script. Let's break down the logic and the implications of this assumption:

### Understanding the Script's Logic

#### Prime Generation:
- Two 256-bit primes `p` and `q` are generated.
- Primes `P` and `Q` are then created by concatenating the decimal representations of `p` and `q` (and vice versa for `q` and `p`).

#### Size of `p` and `q`:
- A 256-bit prime number typically has about 77 decimal digits (since \( \log_{10}(2^{256}) \approx 77 \)).
- Therefore, it's a reasonable assumption for the script to consider `p` and `q` each to be 77 digits long.

### Implications of the Assumption

#### Concatenation of Primes:
- By concatenating the decimal representations, `P = int(str(p) + str(q))` and `Q = int(str(q) + str(p))` are formed.
- This results in `P` and `Q` being approximately 512 bits (or 154 decimal digits) each.

#### Construction of RSA Modulus:
- The RSA modulus `N` is formed by multiplying `P` and `Q`.
- This results in a 1024-bit RSA modulus, which is typical for RSA encryption.

#### Use of Coppersmith's Theorem:
- The assumption about the size of `p` and `q` being 77 digits each is crucial for applying Coppersmith's theorem.
- The theorem is used to find "small" roots of a polynomial, which in this case are the original primes `p` and `q`.

## Conclusion
The assumption that `p` and `q` are precisely 77 digits each is based on the number of bits (256) used to generate these primes and the way they are concatenated to form the larger primes `P` and `Q`. This assumption is essential for the application of Coppersmith's theorem in finding the small roots of the constructed polynomial, which ultimately leads to the factorization of the RSA modulus and the decryption of the ciphertext.
